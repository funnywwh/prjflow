# 微信回调流程重构说明

## 重构目标

扫码初始化、扫码登录、扫码添加用户的流程非常相似，只是获取到用户信息后的业务流程不一样。通过提取公共逻辑，让代码更简洁、可维护。

## 重构架构

### 1. 通用处理函数

**文件**：`backend/internal/api/wechat_callback.go`

创建了通用的微信回调处理函数 `ProcessWeChatCallback`，处理所有场景的公共逻辑：

1. 从 `state` 中提取 `ticket`
2. 检查 `code` 是否存在
3. 读取微信配置（从数据库或配置文件）
4. 验证前置条件（调用 `handler.Validate`）
5. 通知已扫码（WebSocket）
6. 获取 `access_token`
7. 通知正在获取用户信息（WebSocket）
8. 获取用户信息
9. 处理业务逻辑（调用 `handler.Process`）

### 2. 业务处理接口

**接口**：`WeChatCallbackHandler`

每个场景需要实现以下方法：

- `Validate(ctx *WeChatCallbackContext) error` - 验证前置条件
- `Process(ctx *WeChatCallbackContext) (interface{}, error)` - 处理业务逻辑
- `GetSuccessHTML(ctx *WeChatCallbackContext, data interface{}) string` - 获取成功页面HTML
- `GetErrorHTML(ctx *WeChatCallbackContext, err error) string` - 获取错误页面HTML

### 3. 场景实现

#### 登录场景

**文件**：`backend/internal/api/auth.go`

```go
type LoginCallbackHandler struct {
    db *gorm.DB
}
```

- **Validate**：无需特殊验证
- **Process**：查找或创建用户，生成 JWT Token，通过 WebSocket 通知 PC 前端
- **GetSuccessHTML**：返回"登录成功"页面
- **GetErrorHTML**：返回"登录失败"页面

#### 初始化场景

**文件**：`backend/internal/api/init_callback_handler.go`

```go
type InitCallbackHandlerImpl struct {
    db *gorm.DB
}
```

- **Validate**：检查系统是否已初始化，检查微信配置是否已保存
- **Process**：创建管理员角色和用户，分配角色，标记系统已初始化，生成 Token，通过 WebSocket 通知 PC 前端
- **GetSuccessHTML**：返回"系统初始化成功"页面
- **GetErrorHTML**：返回"初始化失败"页面

#### 添加用户场景

**文件**：`backend/internal/api/user_callback_handler.go`

```go
type AddUserCallbackHandler struct {
    db *gorm.DB
}
```

- **Validate**：无需特殊验证
- **Process**：检查用户是否已存在，创建新用户，通过 WebSocket 通知 PC 前端
- **GetSuccessHTML**：返回"用户添加成功"页面
- **GetErrorHTML**：返回"添加用户失败"页面

## 使用方式

### 登录回调

**文件**：`backend/internal/api/auth.go`

```go
func (h *AuthHandler) WeChatCallback(c *gin.Context) {
    code := c.Query("code")
    state := c.Query("state")

    handler := &LoginCallbackHandler{db: h.db}
    ctx, result, err := ProcessWeChatCallback(h.db, h.wechatClient, code, state, handler)
    
    if err != nil {
        c.Data(200, "text/html; charset=utf-8", []byte(handler.GetErrorHTML(ctx, err)))
        return
    }

    c.Data(200, "text/html; charset=utf-8", []byte(handler.GetSuccessHTML(ctx, result)))
}
```

### 初始化回调

**文件**：`backend/internal/api/init_callback.go`

```go
func (h *InitCallbackHandler) HandleCallback(c *gin.Context) {
    code := c.Query("code")
    state := c.Query("state")

    handler := &InitCallbackHandlerImpl{db: h.db}
    ctx, result, err := ProcessWeChatCallback(h.db, h.wechatClient, code, state, handler)
    
    if err != nil {
        c.Data(200, "text/html; charset=utf-8", []byte(handler.GetErrorHTML(ctx, err)))
        return
    }

    c.Data(200, "text/html; charset=utf-8", []byte(handler.GetSuccessHTML(ctx, result)))
}
```

### 添加用户（POST请求）

**文件**：`backend/internal/api/user.go`

```go
func (h *UserHandler) AddUserByWeChat(c *gin.Context) {
    var req struct {
        Code  string `json:"code" binding:"required"`
        State string `json:"state"`
    }

    if err := c.ShouldBindJSON(&req); err != nil {
        utils.Error(c, 400, "参数错误")
        return
    }

    handler := &AddUserCallbackHandler{db: h.db}
    _, result, err := ProcessWeChatCallback(h.db, h.wechatClient, req.Code, req.State, handler)
    
    if err != nil {
        utils.Error(c, utils.CodeError, err.Error())
        return
    }

    utils.Success(c, result)
}
```

## 优势

1. **代码复用**：公共逻辑（获取 access_token、获取用户信息等）只写一次
2. **易于维护**：修改公共逻辑只需修改一处
3. **易于扩展**：新增场景只需实现 `WeChatCallbackHandler` 接口
4. **统一错误处理**：所有场景使用相同的错误处理机制
5. **统一 WebSocket 通知**：所有场景使用相同的通知机制

## 文件结构

```
backend/internal/api/
├── wechat_callback.go          # 通用处理函数和接口定义
├── auth.go                     # 登录场景（LoginCallbackHandler + WeChatCallback）
├── init_callback.go            # 初始化回调入口
├── init_callback_handler.go    # 初始化场景（InitCallbackHandlerImpl）
├── user.go                     # 添加用户入口（AddUserByWeChat）
└── user_callback_handler.go   # 添加用户场景（AddUserCallbackHandler）
```

## 总结

通过提取公共逻辑，三个场景的代码从原来的 200+ 行减少到每个场景只需实现 4 个方法（约 50-100 行），大大提高了代码的可维护性和可扩展性。

