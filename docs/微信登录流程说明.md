# 微信登录流程说明

## 问题分析

### 当前实现的问题

1. **微信回调到前端页面**：
   - 微信重定向到 `https://project.smartxy.com.cn/auth/wechat/callback?code=xxx&state=xxx`
   - 这个回调是在**微信内**打开的，不是 PC 浏览器
   - 前端 `WeChatCallback.vue` 组件在微信内打开，然后调用后端 `POST /api/auth/wechat/login`
   - 虽然后端通过 WebSocket 通知了 PC 前端，但流程不够清晰

2. **问题**：
   - 微信回调页面在微信内打开，PC 浏览器无法直接访问
   - 前端回调页面也在微信内处理了登录，导致逻辑混乱

### 正确的流程应该是

1. **PC 前端显示二维码**
2. **用户扫码** → 微信内打开授权页面
3. **用户确认授权** → 微信重定向到**后端回调接口**
4. **后端处理回调**：
   - 接收 `code` 和 `state`
   - 从 `state` 中提取 `ticket`
   - 调用微信 API 获取用户信息
   - 完成登录逻辑（创建/更新用户、生成 token）
   - 通过 WebSocket 通知 PC 前端登录结果
5. **后端返回 HTML 页面**（在微信内显示"登录成功"）
6. **PC 前端通过 WebSocket 接收通知**：
   - 收到 `success` 消息，包含 token 和用户信息
   - 保存 token 和用户信息
   - 跳转到工作台

## 解决方案

### 1. 创建后端回调接口

**文件**：`backend/internal/api/auth.go`

添加 `WeChatCallback` 方法，处理微信回调：

```go
// WeChatCallback 处理微信授权回调（GET请求，微信直接重定向到这里）
func (h *AuthHandler) WeChatCallback(c *gin.Context) {
	code := c.Query("code")
	state := c.Query("state")
	
	// 从state中提取ticket
	var ticket string
	if state != "" && len(state) > 7 && state[:7] == "ticket:" {
		ticket = state[7:]
	}

	if code == "" {
		// 通过WebSocket通知PC端错误
		if ticket != "" {
			websocket.GetHub().SendMessage(ticket, "error", nil, "未获取到授权码")
		}
		c.Data(200, "text/html; charset=utf-8", []byte(`
			<!DOCTYPE html>
			<html>
			<head>
				<meta charset="UTF-8">
				<title>登录失败</title>
				<style>
					body {
						font-family: Arial, sans-serif;
						display: flex;
						justify-content: center;
						align-items: center;
						height: 100vh;
						margin: 0;
						background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
						color: white;
					}
					.container {
						text-align: center;
					}
				</style>
			</head>
			<body>
				<div class="container">
					<h1>✗ 登录失败</h1>
					<p>未获取到授权码</p>
				</div>
			</body>
			</html>
		`))
		return
	}

	// 调用现有的登录逻辑（复用 WeChatLogin 的逻辑）
	// 这里可以直接调用内部方法，或者重构代码
	// 为了简化，我们可以直接在这里处理
	
	// ... 处理登录逻辑 ...
	// ... 通过 WebSocket 通知 PC 前端 ...
	
	// 返回成功页面
	c.Data(200, "text/html; charset=utf-8", []byte(`
		<!DOCTYPE html>
		<html>
		<head>
			<meta charset="UTF-8">
			<title>登录成功</title>
			<style>
				body {
					font-family: Arial, sans-serif;
					display: flex;
					justify-content: center;
					align-items: center;
					height: 100vh;
					margin: 0;
					background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
					color: white;
				}
				.container {
					text-align: center;
				}
			</style>
		</head>
		<body>
			<div class="container">
				<h1>✓ 登录成功</h1>
				<p>请返回 PC 端查看</p>
			</div>
		</body>
		</html>
	`))
}
```

### 2. 注册后端回调路由

**文件**：`backend/cmd/server/main.go`

```go
authGroup := r.Group("/auth")
{
	authGroup.GET("/wechat/qrcode", authHandler.GetQRCode)
	authGroup.GET("/wechat/callback", authHandler.WeChatCallback)  // 新增：微信回调接口
	authGroup.POST("/wechat/login", authHandler.WeChatLogin)      // 保留：用于其他场景
	authGroup.GET("/user/info", middleware.Auth(), authHandler.GetUserInfo)
	authGroup.POST("/logout", middleware.Auth(), authHandler.Logout)
}
```

### 3. 修改回调 URL

**文件**：`backend/internal/api/auth.go`

修改 `GetQRCode` 方法，回调 URL 指向后端接口：

```go
redirectURI = domain + "auth/wechat/callback"  // 后端接口
```

而不是：

```go
redirectURI = domain + "auth/wechat/callback"  // 前端路由（错误）
```

### 4. 前端只通过 WebSocket 接收结果

**文件**：`frontend/src/views/auth/Login.vue`

前端只需要：
1. 显示二维码
2. 建立 WebSocket 连接
3. 接收 WebSocket 消息
4. 收到 `success` 消息后，保存 token 和用户信息，跳转到工作台

**不需要** `WeChatCallback.vue` 组件（或保留用于其他场景）。

## 总结

- ✅ **微信回调应该到后端接口**：`GET /auth/wechat/callback`
- ✅ **后端处理登录逻辑**：获取用户信息、创建/更新用户、生成 token
- ✅ **后端通过 WebSocket 通知 PC 前端**：发送 token 和用户信息
- ✅ **后端返回 HTML 页面**：在微信内显示"登录成功"
- ✅ **PC 前端通过 WebSocket 接收结果**：保存 token，跳转到工作台

